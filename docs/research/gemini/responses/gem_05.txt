Technical Analysis of Systemd Shim Relocation Logic and Edge Case Validation: Aria Six-Stream Topology Integration
1. Executive Summary
The advent of the Aria programming language ecosystem introduces a radical departure from the established Unix process model through the introduction of the Six-Stream I/O Topology. By formally designating standard streams for telemetry (stddbg), binary input (stddati), and binary output (stddato) alongside the traditional POSIX streams, Aria addresses the long-standing "Noisy Channel" problem in systems programming. However, this architectural innovation precipitates a critical interoperability conflict with the systemd init system, specifically regarding the handling of socket-activated file descriptors.
Systemd rigorously standardizes the passing of activated sockets beginning at File Descriptor (FD) 3, a constant defined as SD_LISTEN_FDS_START. In the Aria runtime environment, FD 3 is contractually reserved for the stddbg telemetry channel, creating a direct resource collision that prevents the reliable startup of Aria-based services managed by systemd. To mediate this conflict without requiring invasive upstream modifications to systemd, the Aria ecosystem employs an aria-activator shim. This userspace component is responsible for relocating the systemd-provided descriptors from the conflict range $
This report provides an exhaustive technical analysis of the file descriptor relocation logic required within the aria-activator shim. It scrutinizes the algorithmic correctness of the relocation strategy, specifically proving that a backward iteration approach ($i = N-1 \dots 0$) is mathematically necessary to prevent data corruption during range overlaps. Furthermore, the report delivers the complete specification and implementation of a rigorous C-based unit test harness (tests/shim/test_fd_relocation.c). This harness is engineered to stress-test the relocation logic against edge cases—particularly where the source and destination descriptor ranges intersect—guaranteeing the robustness of the Aria service activation protocol on Linux systems.
2. Architectural Context: The Unix I/O Paradigm vs. Aria Topology
2.1 The Legacy of the Three-Stream Model
Since the standardization of Version 7 Unix, the interaction between a process and its environment has been mediated by three fundamental file descriptors:
* FD 0 (stdin): The standard input stream, defaulted to text processing.
* FD 1 (stdout): The standard output stream, serving as the primary conduit for program results and user interface text.
* FD 2 (stderr): The standard error stream, utilized for diagnostic messages and failure reporting.
While elegant in its minimalism, this model has suffered from increasing semantic overload in modern distributed systems. "Standard Output" is frequently tasked with carrying structured machine-readable data (e.g., JSON, binary protobufs) while simultaneously serving human-readable status updates. Similarly, "Standard Error" becomes a dumping ground for both critical application failures and benign debug tracing. This conflation leads to the "Noisy Channel" phenomenon, where parsing output becomes fragile, and binary pipelines are easily corrupted by stray log messages.
2.2 Aria's Six-Stream Topology
The Aria language specification mandates a higher-fidelity I/O model designed to segregate concerns at the file descriptor level. This topology is not merely a convention but a runtime requirement enforced by the Aria kernel and standard library.
Table 1: The Aria Six-Stream I/O Topology
FD Index
	Stream Name
	Symbolic Constant
	Primary Semantic Purpose
	Data Type
	0
	stdin
	STDIN_FILENO
	User Input / Control
	Text (UTF-8)
	1
	stdout
	STDOUT_FILENO
	User Interface / Result
	Text (UTF-8)
	2
	stderr
	STDERR_FILENO
	Error Reporting
	Text (UTF-8)
	3
	stddbg
	FD_STDDBG
	Telemetry & Observability
	Structured Logs
	4
	stddati
	FD_STDDATI
	Data Pipeline Input
	Binary (Raw)
	5
	stddato
	FD_STDDATO
	Data Pipeline Output
	Binary (Raw)
	For an Aria application to function correctly, descriptors 0 through 5 must be available for these specific roles upon process initialization. The Aria runtime assumes ownership of these slots to set up the necessary buffering and protocol handlers (e.g., connecting stddbg to a log aggregation daemon). This requirement is formalized as the Reservation Invariant.
2.3 The Systemd Resource Conflict
The conflict arises from the mechanism systemd employs for Socket Activation. When systemd manages a service, it creates the listening sockets defined in the .socket unit file and passes them to the spawned process. To allow the process to identify these sockets, systemd adheres to a strict protocol:
1. Base Index: The first passed file descriptor is always FD 3.2
2. Environment Variable: The variable LISTEN_FDS is set to the integer count of passed descriptors ($N$).
3. Environment Variable: LISTEN_PID is set to the PID of the service to ensure the variables are not accidentally inherited by child processes.
The collision is structural and deterministic. If systemd activates a service with even a single socket, it places that socket at FD 3.
* Aria Expectation: FD 3 is stddbg.
* Systemd Reality: FD 3 is a listening AF_INET or AF_UNIX socket.
If the Aria runtime attempts to write debug logs to FD 3, it will fail with ENOTSOCK (if checking type) or corrupt the socket protocol. Conversely, if the runtime forcibly closes FD 3 to open its own log file, the service loses its listening port, resulting in a denial of service.
The conflict exacerbates as the number of sockets ($N$) increases.
* If $N=1$: FD 3 is occupied.
* If $N=2$: FDs 3 and 4 (stddbg, stddati) are occupied.
* If $N=3$: FDs 3, 4, and 5 (stddbg, stddati, stddato) are occupied.
Therefore, any Aria application launched via systemd socket activation requires an intermediary mechanism to resolve this layout mismatch before the language runtime takes control.
3. Theoretical Analysis of File Descriptor Relocation
The aria-activator shim functions as this intermediary. Its primary directive is to map the systemd-provided file descriptors from the "Conflict Range" to a "Safe Range" that does not impinge on the Six-Stream Topology.
3.1 Mathematical Definition of the Relocation
Let $N$ be the number of file descriptors passed by systemd, derived from parsing getenv("LISTEN_FDS").
Let $S$ be the set of source file descriptors (Systemd allocation):




$$S = \{ s_i \in \mathbb{Z} \mid s_i = 3 + i, \quad 0 \le i < N \}$$
Let $D$ be the set of destination file descriptors (Aria Safe allocation). The safe range begins at ARIA_MIN_FD, which is defined as 6 in the Aria kernel specification to strictly follow the six reserved streams.




$$D = \{ d_i \in \mathbb{Z} \mid d_i = 6 + i, \quad 0 \le i < N \}$$
The relocation function $\mathcal{R}$ maps each element of $S$ to the corresponding element in $D$:




$$\mathcal{R}: s_i \mapsto d_i$$
The operation involves performing a dup2(s_i, d_i) followed by close(s_i) for all $i \in [0, N-1]$.
3.2 The Range Overlap Anomaly
The complexity of this operation is non-trivial because the sets $S$ and $D$ are not guaranteed to be disjoint. An overlap occurs when the upper bound of the source range extends into the lower bound of the destination range.
* Lowest Destination: $\min(D) = 6$.
* Highest Source: $\max(S) = 3 + N - 1 = 2 + N$.
The intersection $S \cap D$ is non-empty if and only if:




$$\max(S) \ge \min(D)$$


$$2 + N \ge 6 \implies N \ge 4$$
However, a closer inspection reveals a hazard even at $N=4$.
* If $N=1$: $S=\{3\}, D=\{6\}$. Disjoint.
* If $N=3$: $S=\{3, 4, 5\}, D=\{6, 7, 8\}$. Disjoint.
* If $N=4$: $S=\{3, 4, 5, 6\}, D=\{6, 7, 8, 9\}$. Intersection at $\{6\}$.
* If $N=5$: $S=\{3, 4, 5, 6, 7\}, D=\{6, 7, 8, 9, 10\}$. Intersection at $\{6, 7\}$.
In the overlapping case, specific file descriptors serve a dual role: they are simultaneously the destination for a lower-indexed relocation and the source for a higher-indexed relocation. This creates a data dependency chain that must be resolved sequentially.
3.3 Failure Analysis: Forward Iteration
A naive implementation might iterate through the descriptors in ascending order ($i = 0, 1, \dots, N-1$). We analyze the failure mode of this strategy using the trace for $N=5$ (Overlapping FDs 6 and 7).
Initial State:
* FD 3: Socket A
* FD 4: Socket B
* FD 5: Socket C
* FD 6: Socket D (This is in the destination range!)
* FD 7: Socket E (This is in the destination range!)
Forward Iteration Execution:
1. Step $i=0$: Relocate FD 3 $\to$ FD 6.
   * Operation: dup2(3, 6).
   * System Side Effect: dup2 atomically closes the existing FD 6 before creating the copy.4
   * Consequence: Socket D (originally in FD 6) is closed and lost. FD 6 now contains a copy of Socket A.
   * Operation: close(3). FD 3 is closed.
2. Step $i=1$: Relocate FD 4 $\to$ FD 7.
   * Operation: dup2(4, 7).
   * System Side Effect: dup2 closes existing FD 7.
   * Consequence: Socket E (originally in FD 7) is closed and lost. FD 7 now contains a copy of Socket B.
   * Operation: close(4).
3. Step $i=2$: Relocate FD 5 $\to$ FD 8.
   * Operation: dup2(5, 8). Safe (FD 8 is empty).
   * Operation: close(5).
4. Step $i=3$: Relocate FD 6 $\to$ FD 9.
   * Intent: Move Socket D to FD 9.
   * Reality: FD 6 currently holds a copy of Socket A (from Step 0).
   * Operation: dup2(6, 9).
   * Consequence: FD 9 becomes a copy of Socket A. Socket D was destroyed in Step 0.
   * Operation: close(6).
Result:
* Expected Output: at FDs 6-10.
* Actual Output: at FDs 6-10.
* Conclusion: Forward iteration causes deterministic data corruption and data loss in overlap scenarios.
3.4 Proof of Correctness: Backward Iteration
Backward iteration ($i = N-1, N-2, \dots, 0$) resolves the dependency hazard by relocating the descriptors in the overlap zone before they are overwritten.
Backward Iteration Execution ($N=5$):
1. Step $i=4$: Relocate FD 7 $\to$ FD 10.
   * Source: $3+4 = 7$. Target: $6+4 = 10$.
   * Operation: dup2(7, 10).
   * State: Socket E is copied to FD 10. FD 10 is outside the source range $S$, so no source is overwritten.
   * Operation: close(7). Original FD 7 is closed. Crucially, the slot FD 7 is now free.
2. Step $i=3$: Relocate FD 6 $\to$ FD 9.
   * Source: $3+3 = 6$. Target: $6+3 = 9$.
   * Operation: dup2(6, 9).
   * State: Socket D is copied to FD 9. FD 9 is outside remaining $S$.
   * Operation: close(6). Original FD 6 is closed. Slot FD 6 is now free.
3. Step $i=2$: Relocate FD 5 $\to$ FD 8.
   * Source: 5. Target: 8.
   * Operation: dup2(5, 8). Safe.
   * Operation: close(5).
4. Step $i=1$: Relocate FD 4 $\to$ FD 7.
   * Source: 4. Target: 7.
   * Operation: dup2(4, 7).
   * Safety Check: FD 7 is the target. Is FD 7 occupied? No, it was closed in Step 1.
   * State: Socket B is copied to FD 7.
   * Operation: close(4).
5. Step $i=0$: Relocate FD 3 $\to$ FD 6.
   * Source: 3. Target: 6.
   * Operation: dup2(3, 6).
   * Safety Check: FD 6 is the target. Is FD 6 occupied? No, it was closed in Step 2.
   * State: Socket A is copied to FD 6.
   * Operation: close(3).
Result:
* FDs 6, 7, 8, 9, 10 contain Sockets A, B, C, D, E respectively.
* Data integrity is preserved.
* FDs 3, 4, 5 are closed and available for Aria initialization.
3.5 System Call Semantics and O_CLOEXEC
A critical detail in this logic is the behavior of the Close-on-Exec (FD_CLOEXEC) flag. Systemd typically sets this flag on the file descriptors it passes to the service (via sd_listen_fds) to ensure hygiene.6
* dup2 Behavior: The dup2 system call creates a new file descriptor that refers to the same open file description as the old one. Crucially, the new descriptor (the copy) does not inherit the FD_CLOEXEC flag; it is cleared by default.5
* Implication for Shim: This is the desired behavior. The shim's purpose is to set up the environment and then execve the actual Aria binary. If the relocated descriptors (6+) retained O_CLOEXEC, they would be closed by the kernel during the shim's transition to the Aria application, defeating the purpose of the relocation. The clearing of the flag ensures the sockets persist into the target process.
4. Implementation Specification
Based on the theoretical analysis, the implementation of the aria-activator shim requires a specific sequence of operations. The following section details the C implementation of the logic, focusing on robustness and error handling.
4.1 Test Harness Design Strategy
To validate this logic without setting up a complex systemd environment, a standalone C test harness is required. The harness must simulate the kernel state that systemd creates.
Key Requirements for the Test Harness:
1. Deterministic Simulation: The test cannot rely on socket() returning sequential FDs 3, 4, 5... because the kernel allocator might return different IDs or other libraries might have opened files. The test must use dup2 to force test pipes into the specific source slots (3, 4, 5, etc.) required to simulate the conflict.
2. Content Verification: Testing purely for the existence of an FD is insufficient. The test must prove that the data associated with FD 3 moves to FD 6. This is achieved by creating pipes, writing a unique "signature" string to the write-end, and verifying that the signature can be read from the relocated read-end.
3. Conflict Simulation: To verify the overlap handling, the test setup must ensure that FDs in the destination range (e.g., FD 6) are populated with "trap" data before the relocation begins. This proves that the backward iteration correctly handles the overwrite.
4.2 Unit Test Implementation (test_fd_relocation.c)


C




/*
* tests/shim/test_fd_relocation.c
*
* Unit Test for Aria Activator Shim: File Descriptor Relocation Logic
*
* Context:
* The shim must relocate systemd-provided FDs from range; // Unique data string written to the pipe
} PipeContext;

/**
* Helper: Create a pipe and force its read-end to a specific target FD.
* This simulates systemd passing a socket at a specific index.
*/
void setup_pipe_at_fd(int target_fd, PipeContext *ctx, int index) {
   int fds;
   
   // Create a pipe. fds is read, fds is write.
   if (pipe(fds) < 0) {
       perror("pipe failed");
       exit(1);
   }

   // Assign Write FD (we keep this to verify data later)
   ctx->write_fd = fds;
   ctx->original_fd = target_fd;
   ctx->expected_fd = ARIA_TARGET_FD + index;

   // Force Read FD to target_fd using dup2
   // If pipe() returned the target_fd by chance, dup2 is a no-op.
   if (fds!= target_fd) {
       if (dup2(fds, target_fd) < 0) {
           fprintf(stderr, "Failed to force pipe to FD %d: %s\n", target_fd, strerror(errno));
           exit(1);
       }
       // Close the original random FD provided by pipe()
       close(fds); 
   }

   // Generate unique signature based on the index
   snprintf(ctx->signature, sizeof(ctx->signature), "SOCKET_DATA_INDEX_%d_UID_%x", index, rand());

   // Write the signature to the pipe immediately
   // The data sits in the kernel buffer until we read it from the relocated FD.
   if (write(ctx->write_fd, ctx->signature, strlen(ctx->signature)) < 0) {
       perror("write signature failed");
       exit(1);
   }
}

/**
* THE ALGORITHM UNDER TEST
* Shim logic to relocate N descriptors from start_fd to target_fd.
* 
* This function implements the Backward Iteration strategy.
*/
void relocate_fds(int n_fds, int start_fd, int target_fd) {
   printf("%s Relocating %d FDs from %d -> %d%s\n", 
          COLOR_BLUE, n_fds, start_fd, target_fd, COLOR_RESET);

   // CRITICAL LOGIC: Backward Iteration
   // We iterate from the last FD down to 0.
   // Loop invariant: i is the offset from the base FD.
   for (int i = n_fds - 1; i >= 0; i--) {
       int old_fd = start_fd + i;
       int new_fd = target_fd + i;

       printf("  -> Processing: dup2(%d, %d), close(%d)\n", old_fd, new_fd, old_fd);

       // Atomic duplication
       if (dup2(old_fd, new_fd) < 0) {
           fprintf(stderr, "    FATAL: dup2(%d, %d) failed: %s\n", 
                   old_fd, new_fd, strerror(errno));
           exit(2);
       }

       // Close the source to free it up for Aria
       close(old_fd);
   }
}

/**
* Validation Helper: Read from FD and compare with expected signature.
*/
void verify_fd_content(int fd, const char *expected_sig) {
   char buffer;
   memset(buffer, 0, sizeof(buffer));

   // We verify the FD is open first
   if (fcntl(fd, F_GETFD) == -1) {
       fprintf(stderr, "%sFAIL%s: FD %d is closed (expected open).\n", 
               COLOR_RED, COLOR_RESET, fd);
       exit(1);
   }

   // Read from the pipe
   ssize_t bytes = read(fd, buffer, sizeof(buffer) - 1);
   
   if (bytes < 0) {
       fprintf(stderr, "%sFAIL%s: Read from FD %d failed: %s\n", 
               COLOR_RED, COLOR_RESET, fd, strerror(errno));
       exit(1);
   }

   // Compare content
   if (strncmp(buffer, expected_sig, strlen(expected_sig))!= 0) {
       fprintf(stderr, "%sFAIL%s: Data mismatch on FD %d.\n", COLOR_RED, COLOR_RESET, fd);
       fprintf(stderr, "      Expected: '%s'\n", expected_sig);
       fprintf(stderr, "      Got:      '%s'\n", buffer);
       exit(1);
   }
}

/**
* Validation Helper: Ensure FD is closed.
*/
void verify_fd_closed(int fd) {
   // fcntl returns -1 and sets errno to EBADF if fd is closed
   if (fcntl(fd, F_GETFD)!= -1 |

| errno!= EBADF) {
       fprintf(stderr, "%sFAIL%s: FD %d should be closed but is open.\n", 
               COLOR_RED, COLOR_RESET, fd);
       exit(1);
   }
}

/**
* Test Case Runner
*/
void run_test_case(int n_fds) {
   printf("\n%s=== Running Test Case: N=%d ===%s\n", COLOR_BLUE, n_fds, COLOR_RESET);
   
   PipeContext pipes;

   // 1. SETUP: Create systemd-like environment
   // We populate Creating %d pipes starting at FD %d...\n", n_fds, SYSTEMD_START_FD);
   for (int i = 0; i < n_fds; i++) {
       setup_pipe_at_fd(SYSTEMD_START_FD + i, &pipes[i], i);
   }

   // 2. EXECUTE: Run the shim logic
   relocate_fds(n_fds, SYSTEMD_START_FD, ARIA_TARGET_FD);

   // 3. VERIFY: Check integrity of relocated data
   printf("  [Verify] Validating data integrity at destination...\n");
   for (int i = 0; i < n_fds; i++) {
       int expected_fd = pipes[i].expected_fd;
       
       // Check content
       verify_fd_content(expected_fd, pipes[i].signature);
       
       // Clean up: Close write end
       close(pipes[i].write_fd);
       // Clean up: Close the new read end (cleanup for next test)
       close(expected_fd);
   }

   // 4. VERIFY: Ensure Aria reserved range (3, 4, 5) is free
   // This is crucial. Even if N=1, FD 3 must be closed.
   printf("  [Verify] Checking source FDs (Aria Reserved Range) are closed...\n");
   for (int i = 0; i < n_fds; i++) {
       // We only check the ones we moved. 
       // If N=1, we check FD 3. FD 4 and 5 might be untouched by this operation 
       // (but presumably empty in a clean harness).
       verify_fd_closed(SYSTEMD_START_FD + i);
   }

   printf("%sPASS%s: Test Case N=%d successful.\n", COLOR_GREEN, COLOR_RESET, n_fds);
}

int main() {
   printf("Starting Aria Activator Shim FD Relocation Logic Tests\n");
   printf("Configuration: Source Base %d -> Target Base %d\n", SYSTEMD_START_FD, ARIA_TARGET_FD);

   // Sanity check: Ensure we aren't running in a weird state where 3,4,5 are already used
   // by the shell running this test. We might need to close them or fail.
   // For this unit test, we assume a standard execution where 0,1,2 are open.
   
   // Case 1: Single socket (N=1)
   // Range:  -> 
   // Overlap: None
   run_test_case(1);

   // Case 2: Boundary Condition (N=3)
   // Range:  -> 
   // Overlap: None (Source end is 5, Dest start is 6)
   run_test_case(3);

   // Case 3: The Critical Overlap (N=5)
   // Range:  -> 
   // Overlap: {6, 7}
   // This is the regression test for Forward Iteration failure.
   run_test_case(5);

   // Case 4: Massive Overlap (N=10)
   // Range: [3..12] -> [6..15]
   // Overlap: {6..12}
   run_test_case(10);

   printf("\n%sAll tests passed successfully.%s\n", COLOR_GREEN, COLOR_RESET);
   return 0;
}

5. Test Case Analysis and Trace Verification
5.1 Test Case $N=1$ (Disjoint)
* Scenario: A single listening socket passed by systemd (e.g., a simple web server).
* Source: {3}. Destination: {6}.
* Trace:
   1. $i=0$: dup2(3, 6), close(3).
* Validation: The test verifies that data written to the pipe at 3 is readable at 6. It confirms 3 is closed.
* Implication: This confirms basic functionality for non-overlapping cases.
5.2 Test Case $N=3$ (Boundary Adjacency)
* Scenario: Three sockets passed. The source range fills the Aria reservation exactly ($3, 4, 5$).
* Source: {3, 4, 5}. Destination: {6, 7, 8}.
* Trace (Backward):
   1. Move 5 $\to$ 8. Close 5.
   2. Move 4 $\to$ 7. Close 4.
   3. Move 3 $\to$ 6. Close 3.
* Analysis: The ranges are adjacent but disjoint. Forward iteration would also work here, but backward iteration is valid. The test confirms no off-by-one errors exist at the boundary of FD 6.
5.3 Test Case $N=5$ (Overlap and Collision)
* Scenario: Five sockets passed.
* Source: $\{3, 4, 5, 6, 7\}$. Destination: $\{6, 7, 8, 9, 10\}$.
* Intersection: FDs 6 and 7 are both inputs and outputs.
* Trace (Backward):
   1. Move 7 $\to$ 10: FD 7 is duplicated to safe slot 10. FD 7 is closed. CRITICAL: FD 7 is now free to receive the move from FD 4.
   2. Move 6 $\to$ 9: FD 6 is duplicated to safe slot 9. FD 6 is closed. CRITICAL: FD 6 is now free to receive the move from FD 3.
   3. Move 5 $\to$ 8: Safe.
   4. Move 4 $\to$ 7: Safe (target 7 was cleared in step 1).
   5. Move 3 $\to$ 6: Safe (target 6 was cleared in step 2).
* Verification: The test writes signature SOCKET_DATA_INDEX_3 to the pipe at FD 6 initially. It verifies that this specific signature is readable from FD 9 at the end. If forward iteration were used, FD 9 would contain the signature from FD 3 (SOCKET_DATA_INDEX_0), triggering a failure assertion.
6. Integration and Security Considerations
6.1 Interaction with aria_ensure_streams
The AriaX kernel specification modifies fs/exec.c to include aria_ensure_streams, a function that populates empty FDs 3-5 with /dev/null.
* Pre-Shim Execution: When systemd execs the shim, the kernel sees FDs 3-5 populated (by systemd). aria_ensure_streams takes no action.
* Post-Shim Execution: When the shim execs the Aria binary, it has already closed FDs 3-5.
* Re-Entry: The kernel's execve handler runs again for the Aria binary. It detects FDs 3-5 are closed. It triggers aria_ensure_streams to populate them (likely with /dev/null or pipes if the shim set them up).
* Result: The shim successfully "clears the landing zone," allowing the kernel to enforce the Reservation Invariant cleanly.
6.2 Atomic Operations and Thread Safety
The use of dup2 ensures atomicity at the system call level. If the destination FD exists, the kernel acquires the necessary spinlocks on the files_struct to close and overwrite it in a single operation. While the shim is single-threaded, this kernel-level atomicity prevents race conditions with any spurious threads or signal handlers that might be inspecting file descriptors.
7. Conclusion
The conflict between the systemd socket activation protocol ($SD\_LISTEN\_FDS\_START = 3$) and the Aria Six-Stream Topology (FD 3 = stddbg) is a fundamental architectural constraint of the ecosystem. The aria-activator shim provides the necessary adaptation layer to resolve this conflict.
The analysis conclusively demonstrates that a backward iteration strategy ($i = N-1 \dots 0$) is the only algorithm that guarantees data integrity when the number of passed descriptors exceeds 3. By processing the upper range of descriptors first, the logic resolves the overlap dependencies inherent in shifting a contiguous range of integers to a higher base. The provided C unit test harness, utilizing pipe-based data verification, offers a rigorous method to validate this logic across all edge cases, ensuring that Aria applications can be reliably deployed in systemd-managed environments without risk of stream corruption or data loss.
7.1 Compilation Instructions
The provided test harness is self-contained. To compile and run on a Linux system:


Bash




gcc -O2 -Wall -Wextra -o test_fd_relocation tests/shim/test_fd_relocation.c
./test_fd_relocation

Successful execution of all four test cases serves as validation of the shim's logic for the production release.
Works cited
1. sd_listen_fds - Freedesktop.org, accessed December 22, 2025, https://www.freedesktop.org/software/systemd/man/sd_listen_fds.html
2. sd_listen_fds, SD_LISTEN_FDS_START - Check for file descriptors passed by the system manager - Ubuntu Manpage, accessed December 22, 2025, https://manpages.ubuntu.com/manpages/trusty//man3/sd_listen_fds.3.html
3. Duplicating Descriptors (The GNU C Library), accessed December 22, 2025, http://www.gnu.org/s/libc/manual/html_node/Duplicating-Descriptors.html
4. dup(2) - Linux manual page - man7.org, accessed December 22, 2025, https://man7.org/linux/man-pages/man2/dup2.2.html
5. sd_listen_fds(3) — libsystemd-dev — Debian testing, accessed December 22, 2025, https://manpages.debian.org/testing/libsystemd-dev/sd_listen_fds.3.en.html
6. dup2() — Duplicate an open file descriptor to another - IBM, accessed December 22, 2025, https://www.ibm.com/docs/en/zos/2.5.0?topic=functions-dup2-duplicate-open-file-descriptor-another