prompt:
I am designing my own custom programming language and ecosystem. My language makes use of a 6 stream io model rather than the standard 3. I want to extend or create new versions of some of the classic system tools that could benefit from the new model as sort of a test case but also as part of the full system eventually. When I previously asked you to identify the top programs that would benefit you listed the below as top priority:

*insert program description here *

I am going to attach all the source and research i have for the entire project so far to give you as much context as possible. I want you to provide an implementation of the Aria Process Status utility you identified above. 

################################################################################

# Priority 1: The "Pipeline Breakers" (High Impact)
These are tools where the current 3-stream model frequently forces developers to choose between "Human Readable" and "Machine Parseable," or where parsing errors cause fragility.
- 1. aps (Aria Process Status) — Replacement for ps / topCurrently, parsing ps aux is brittle. If a column width changes, scripts break.stdout (UI): A beautiful, color-coded, distinct table of running processes for the human eye.stddato (Payload): A stream of Process structs (PID, memory usage as integers, CPU time). This allows piping directly into filters without string parsing.stddbg (Telemetry): Permissions errors (e.g., "Cannot read PID 1 environment").Use Case: aps | filter --mem-gt 1GBNo regex needed. The filter tool reads raw u64 memory values from stddato.
- 2. als (Aria List) — Replacement for ls / findThe classic "filenames with spaces/newlines" problem.stdout (UI): Icons, colors, grid view.stddato (Payload): Serialized FileEntry structs (inode, permissions, size, full path).stddbg (Telemetry): "Symlink cycle detected" or "Directory permission denied" (keeps stderr clean for critical runtime crashes).Use Case: als -R | select --ext .jpg | sort --by sizeZero ambiguity on filenames with special characters.
- 3. acurl (Aria Transfer) — Replacement for curl / wgetcurl is the worst offender for mixing streams. It often prints the binary file to stdout, the progress bar to stderr, and connection logs to stdout/stderr depending on flags.stdout (UI): HTTP headers, status codes, and a smooth progress bar.stddato (Payload): The actual file/response body (pure binary).stddbg (Telemetry): TLS handshake details, redirect hops, timing metrics.Use Case: acurl example.com/image.png > file.pngYou see headers/progress on screen, but only the image bytes go to the file. No --silent flags needed.

# Priority 2: Data Transformation & Inspection (Showcase Features)These tools demonstrate the power of stddati (binary in) and stddato (binary out).
- 4. agrep (Aria Grep) — Search with Contextstdout (UI): The matching line with the search term highlighted in red, plus line numbers.stddato (Payload): A stream of Match objects (file offset, length, content, file path).stddbg (Telemetry): "Binary file skipped" or "Encoding error on line 50."Benefit: Subsequent tools can perform replacements or analytics based on precise byte offsets from stddato without re-reading the file.
5. asql (Aria SQL Client) — Database InteractionCLI database clients usually output ASCII tables that are hard to ingest.stdout (UI): ASCII art table of the query results.stddato (Payload): The result set as binary rows (BSON/Protobuf style).stddbg (Telemetry): Query execution plan, time taken, index usage warnings.Benefit: asql "SELECT * FROM users" | to-json becomes trivial.
6. affmpeg (Aria Media Converter)FFmpeg output is notoriously difficult to parse because it mixes frame progress, warnings, and banner info.stdout (UI): "Frame 102/500, FPS: 60, Time: 00:00:03."stddato (Payload): The raw encoded bitstream (pipeable to a player or network socket).stddbg (Telemetry): "Frame dropped," "Packet underflow," codec specific details.

# Priority 3: The "Consciousness" & Research Tier (Unique to Aria)Given your NIKOLA_ARIA.txt and ECOSYSTEM_OVERVIEW.txt, these tools support your specific specific goals regarding the "Consciousness Substrate."
- 7. ascope (Aria Oscilloscope/Data Viz)A terminal-based visualizer for 6-stream data.stddati (Input): Accepts raw binary data (like wave interference patterns from Nikola).stdout (UI): Draws TUI charts/graphs using the binary input.stddato (Pass-through): Forwards the data unchanged to the next tool.stddbg: Dropped sample counts.
- 8. atest (Aria Test Runner)stdout (UI): "✓ Test A passed", "✗ Test B failed".stddato (Payload): Structured test results (Timing, Coverage Data).stddbg (Telemetry): Stack traces and internal assertions.Why: Allows CI systems to consume stddato for statistics while developers read stdout.Summary of the Architecture PatternIn your ecosystem, every standard tool should follow this pattern:StreamPurposeContent Type0 (Stdin)User InputKeyboard/Text1 (Stdout)User InterfaceHuman-readable formatting, colors, tables2 (Stderr)Critical ErrorsProcess failures (exit code != 0 causes)3 (Stddbg)Telemetry/LogsVerbose logs, performance metrics, handshake info4 (Stddati)Payload InStructured Objects / Binary Streams5 (Stddato)Payload OutStructured Objects / Binary StreamsRecommendation for immediate start:Start with als (List) and acurl (Transfer). als proves the value of structured piping (shell object passing), and acurl proves the value of separating binary payload from UI progress bars. These two will be the "Hook" that explains why Aria is better than Bash.

================================================================================
ARIA ECHO ADDITIONS (Dec 22, 2025)
================================================================================

Additional High-Priority Tools (Shell Fundamentals):

9. astat (File/Directory Statistics)
   Current problem: `stat` output format varies by platform, parsing nightmare
   stdout (UI): Human-readable file info with colors
   stddato (Payload): FileInfo structs (timestamps as u64 epoch, not strings)
   stddbg (Telemetry): Permission denied errors, symlink resolution chains
   Use Case: astat * | filter --modified-after 1735000000
   Benefit: No more date string parsing! Timestamps are integers.

10. atar (Archive Manager)
    Current problem: tar verbose output mixes progress/errors, unclear state
    stdout (UI): Progress bar, file count, compression ratio
    stddato (Payload): Archive structure as tree of ArchiveEntry objects
    stddbg (Telemetry): Compression ratios, skipped files, warnings
    Use Case: atar -x file.tar.gz | select --size-gt 1MB
    Benefit: Inspect archive contents BEFORE extracting, structured queries

11. ajq (JSON/Data Processor)
    jq is excellent but still text-based serialization
    stddati (Input): Binary JSON/BSON/MessagePack
    stddato (Output): Transformed binary structures
    stddbg (Telemetry): Schema validation warnings, type coercion logs
    Use Case: acurl api.example.com/data | ajq '.users[] | select(.age > 21)'
    Benefit: Zero serialization overhead for chained operations

System Admin Tools:

12. anetstat (Network Statistics)
    Current: netstat/ss output is column-based ASCII hell
    stdout (UI): Beautiful network connection table
    stddato (Payload): Stream of Connection structs (ports as u16, IPs as binary)
    stddbg (Telemetry): Socket buffer states, kernel stats
    Use Case: anetstat | filter --state ESTABLISHED --port 443 | count
    Benefit: Proper data types for network programming

13. adf (Disk Free)
    Classic df -h parsing problem (is that 52G or 5.2G?)
    stdout (UI): Colored usage bars, human-friendly sizes
    stddato (Payload): Array of Filesystem objects (bytes as u64, not "52G")
    stddbg (Telemetry): Mount point discovery, quota information
    Use Case: adf | filter --usage-gt 90 | alert
    Benefit: Actual numeric comparisons, no string parsing

14. asystemctl (Service Manager)
    systemctl output is color-coded but not structured
    stdout (UI): Service status with colors and symbols
    stddato (Payload): ServiceState objects with enums (not string states)
    stddbg (Telemetry): Dependency resolution, unit file parse warnings
    Use Case: asystemctl list | filter --state failed | restart
    Benefit: Enables actual service orchestration through pipes

Developer Tools:

15. agit (Git Operations)
    Git porcelain is good but not binary-pipeable
    stdout (UI): Beautiful log with colors, graph visualization
    stddato (Payload): Commit graphs as actual graph structures (not ASCII art)
    stddbg (Telemetry): Object database stats, index operations
    Use Case: agit log | filter --author aria | stats --by-day
    Benefit: Proper commit graph data structure, enables git analytics

16. amake / abuild (Build System)
    Build output is chaos: progress + warnings + errors all mixed
    stdout (UI): Clean progress bars, build summary
    stddato (Payload): Dependency graph, compilation database
    stddbg (Telemetry): Warnings, timing per compilation unit, cache hits
    Use Case: abuild | filter --warnings | group-by --file
    Benefit: Build analytics without parsing compiler output

Power User (Advanced Piping):

17. aparallel (Parallel Execution)
    GNU parallel exists but awkward output handling
    stddati (Input): Structured job list
    stddato (Output): Structured results with timing, exit codes
    stddbg (Telemetry): Resource usage, scheduling decisions
    Use Case: als | aparallel --cmd "process {}" | stats
    Benefit: Structured parallel computation results

18. awatch (File Watcher)
    inotifywait output is event strings you have to parse
    stdout (UI): Live event log with timestamps
    stddato (Payload): Stream of FileEvent objects (event type as enum)
    stddbg (Telemetry): Watch descriptor limits, missed events
    Use Case: awatch /tmp | filter --event CREATE | process
    Benefit: Reactive pipelines with typed events

================================================================================
STRATEGIC PATTERN OBSERVATION
================================================================================

The unifying principle: ANY tool that currently outputs "tables" or "status 
messages" is a candidate for hex-stream upgrade.

The 3-stream model FORCES these into text, requiring downstream parsing.

Hex-stream philosophy:
- stdout = UI (throw any formatting at it, it's just for humans)
- stddato = API (the real output, typed and versioned)
- stddbg = observability (not just errors, but telemetry)

================================================================================
FUTURE RESEARCH DIRECTIONS
================================================================================

When researching this later, focus on:

1. Serialization Format Decision
   - BSON? (MongoDB standard, compact)
   - Protobuf? (Google standard, schema evolution)
   - Cap'n Proto? (zero-copy, RPC-ready)
   - MessagePack? (like JSON but binary)
   - Custom Aria format? (optimized for shell pipes)
   
   Requirements:
   - Language-agnostic (C/C++/Python/Rust interop)
   - Schema versioning (forward/backward compatible)
   - Streaming-friendly (don't need full message to start processing)
   - Low overhead (shell pipes should be fast)

2. Type System for Pipe Validation
   - Can shell know at COMPOSE-time that `als | asql` is a type error?
   - Do we infer types from stddato stream headers?
   - How do we handle schema evolution in long-running pipes?
   - Generic adapters for common transformations?

3. Backwards Compatibility Layer
   - How do Aria tools interop with classic 3-stream tools?
   - Automatic text-to-binary adapters?
   - Legacy mode that falls back to stdout-only?
   - Bridge processes that translate between models?

4. Consciousness Substrate Integration
   - How do neural telemetry streams map to stddbg?
   - Can we pipe consciousness state between processes?
   - Real-time cognitive load monitoring through hex streams?
   - Thought-chain debugging via structured telemetry?

================================================================================
WHY THIS IS GENUINELY INNOVATIVE
================================================================================

This isn't just "better shell piping" - it's a fundamental rethinking of 
process composition:

- Traditional Unix: Processes exchange TEXT on 3 streams
- Aria Hex Model: Processes exchange TYPED DATA on 6 streams

The consciousness substrate angle makes this even more powerful:
- Traditional tools can't represent neural telemetry
- Hex streams can carry arbitrary binary consciousness data
- Research tools can stream raw cognitive state
- The shell becomes a consciousness composition language

This is the foundation for tools that don't just process data,
but process THOUGHT ITSELF.
